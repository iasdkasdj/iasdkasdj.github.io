<!doctype html>
<html lang="en">
   <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width , initial-scale=1 , user-scalable=no">
  <title>在UI中利用键盘的底层事件</title>
<style>
*{
    margin: 10px;
    text-align: center;
  }
  header{
    border: 3px solid  green;
    
  }
  nav{
    border: 3px solid  green;
    height: 10%;
  }
  main{
    border: 3px solid  green;
    height: 70%;
    font-size: 0.8em;  
    position: relative;
  }

  #box{
    position: absolute;
    right: 0;
    width: 100px;
  }

  footer{
    border: 3px solid  green;
    height:10%;
    font-size: 0.7em;
  } 
  body{
    position: relative;
  }
  #aid{
    position: absolute;
    border: 3px solid blueviolet;
    top:0px;
    left:600px;
  }
  #bookface{
    position: absolute;
    width: 80%;
    height: 80%;
    border:1px solid  red;
    background-image: url(); /* 添加你的背景图片 */
    background-size: cover;
    background-position: center;
    left:7% ;
    top: 7% ;
    transition: opacity 0.5s ease;
  }
  #book {
    font-family: Arial, sans-serif; /* 使用一个美观的无衬线字体 */
    font-size: 1em; /* 调整字体大小 */
    font-weight: bold; /* 使用粗体字体 */
    color: #333; /* 设置字体颜色 */
    text-transform: uppercase; /* 将文字转换为大写 */
    letter-spacing: 1px; /* 增加字母间距 */
}
nav button {
    margin: 0 5px; /* 调整按钮间距 */
    padding: 8px 16px; /* 添加填充以改善按钮外观 */
    font-size: 0.7em; /* 设置按钮字体大小 */
    cursor: pointer;
    border: none;
    border-radius: 5px; /* 添加圆角以使按钮更圆润 */
    background-color: #4CAF50; /* 添加背景颜色 */
    color: white;
    transition: background-color 0.3s ease; /* 悬停时平滑过渡背景颜色 */
}
nav button:hover {
    background-color: #45a049; /* 悬停时加深背景颜色 */
}
#forwardBtn, #backwardBtn, #pauseBtn {
    margin: 10px;
}
</style>
</head> 
<body >
  <header>
    <p id="book">
     《我的毕设题目》
    </p>
   </header>
   <nav>
    <button id="backwardBtn">后退</button>
    <button id="pauseBtn">暂停播放</button>
    <button id="forwardBtn">前进</button>
  </nav>
 

   <main id="main">
	<div id="bookface">
        本利代码的运行需要超过1千像素宽度的宽屏<br>
	    建议使用有键盘的PC运行和调试代码<br>
        当然拖动/滑动超过100像素的UI互动依然有效！
    </div>
   </main>

  <footer> 
   
	CopyRight 张梓鑫 江西科技师范大学 2024--2025

  </footer> 
  <div id="aid">
   用户键盘响应区
   <p id="typeText"></p>
   <hr>
   <p id="keyboard"></p> 
  </div>
 <script>
  const images = ['../lesson/webProgramming.jpg', '../lesson/logic.jpg', '../lesson/gitForTeams.jpg'];
let currentIndex = 0;
let intervalId = null;
let isPlaying = true; // 标记自动播放状态，默认为true表示正在播放
  var UI = {};
  if(window.innerWidth>600){
    UI.appWidth=600;
      }else{
    UI.appWidth = window.innerWidth;
  }


  UI.appHeight = window.innerHeight; 

  let baseFont = UI.appWidth /20;
  //通过改变body对象的字体大小，这个属性可以影响其后代
  document.body.style.fontSize = baseFont +"px";
  //通过把body的高度设置为设备屏幕的高度，从而实现纵向全屏
  //通过CSS对子对象百分比（纵向）的配合，从而达到我们响应式设计的目标
  document.body.style.width = UI.appWidth - baseFont + "px";
  document.body.style.height = UI.appHeight - baseFont*5 + "px";
if(window.innerWidth<1000){
    $("aid").style.display='none';
}
  $("aid").style.width=window.innerWidth-UI.appWidth - baseFont*3 +'px';
  $("aid").style.height= UI.appHeight - baseFont*3 +'px';

//尝试对鼠标和触屏设计一套代码实现UI控制
var Pointer = {};
 Pointer.isDown= false;
 Pointer.x = 0;
 Pointer.deltaX =0;
 { //Code Block Begin
   let handleBegin = function(ev){
    Pointer.isDown=true;
    
	if(ev.touches){console.log("touches1"+ev.touches);
		Pointer.x = ev.touches[0].pageX ;
        Pointer.y = ev.touches[0].pageY ;
		console.log("Touch begin : "+"("+Pointer.x +"," +Pointer.y +")" ) ;
        $("bookface").textContent= "触屏事件开始，坐标："+"("+Pointer.x+","+Pointer.y+")";
	}else{
	  Pointer.x= ev.pageX;
      Pointer.y= ev.pageY;
      console.log("PointerDown at x: "+"("+Pointer.x +"," +Pointer.y +")" ) ;
      $("bookface").textContent= "鼠标按下，坐标："+"("+Pointer.x+","+Pointer.y+")";
	}
   };
  let handleEnd = function(ev){
   Pointer.isDown=false;
   ev.preventDefault()
   //console.log(ev.touches)
   if(ev.touches){
     $("bookface").textContent= "触屏事件结束!";
     if(Math.abs(Pointer.deltaX) > 100){
         $("bookface").textContent += "，这是有效触屏滑动！"  ;
     }else{
	    $("bookface").textContent += " 本次算无效触屏滑动！"  ;
		$("bookface").style.left = '7%' ;
	 }
   }else{ 
   
     $("bookface").textContent= "鼠标松开!";
     if(Math.abs(Pointer.deltaX) > 100){
         $("bookface").textContent += "，这是有效拖动！"  ;
     }else{
	    $("bookface").textContent += " 本次算无效拖动！"  ;
		$("bookface").style.left = '7%' ;
		}
   }
  };
 let handleMoving = function(ev){
    ev.preventDefault();
   if (ev.touches){
     if (Pointer.isDown){
	   console.log("Touch is moving");
	   Pointer.deltaX = parseInt( ev.touches[0].pageX - Pointer.x );
	   $("bookface").textContent= "正在滑动触屏，滑动距离：" + Pointer.deltaX +"px 。";
	   $('bookface').style.left =  Pointer.deltaX + 'px' ;
     } 
   }else{
     if (Pointer.isDown){
	   console.log("Pointer isDown and moving");
	   Pointer.deltaX = parseInt( ev.pageX - Pointer.x );
	   $("bookface").textContent= "正在拖动鼠标，距离：" + Pointer.deltaX +"px 。";
	   $('bookface').style.left =  Pointer.deltaX + 'px' ;
     } 
   }
  };

  $("bookface").addEventListener("mousedown",handleBegin );
  $("bookface").addEventListener("touchstart",handleBegin );
  $("bookface").addEventListener("mouseup", handleEnd );
  $("bookface").addEventListener("touchend",handleEnd );
  $("bookface").addEventListener("mouseout", handleEnd );
  $("bookface").addEventListener("mousemove", handleMoving);
  $("bookface").addEventListener("touchmove", handleMoving);

 /**** 添加"keydown"和"keyup"这2个键盘底层事件处理后，keypress这个高层键盘事件响应被系统忽略
  $("body").addEventListener("keypress", function(ev){
    $("typeText").textContent += ev.key ;
  });

  $("body").addEventListener("keydown",function(ev){
	ev.preventDefault() ;
    let k = ev.key;
    let c = ev.keyCode;
    $("keyboard").textContent = "您已按键 ：" + k + " ，"+ "字符编码 ：" + c;
   });
 $("body").addEventListener("keyup",function(ev){
	ev.preventDefault() ;
    let k = ev.key;
    let c = ev.keyCode;
    $("keyboard").textContent = "松开按键 ：" + k + " ，"+ "字符编码 ：" + c;
 });
**********/
 //提出问题：研究利用"keydown"和"keyup"2个底层事件，实现同时输出按键状态和文本内容
    $("body").addEventListener("keydown",function(ev){
	ev.preventDefault() ;
    let k = ev.key;
    let c = ev.keyCode;
    $("keyboard").textContent = "您已按键 ：" + k + " ，"+ "字符编码 ：" + c;
   });
 $("body").addEventListener("keyup",function(ev){
	ev.preventDefault() ;
    let key = ev.key;
    let code = ev.keyCode;
    $("keyboard").textContent = "松开按键 ：" + key + " ，"+ "字符编码 ：" + code;
    if (printLetter(key)){
	    $("typeText").textContent += key ;
	 }
    function printLetter(k){
	 if (k.length > 1){ //学生必须研究这个逻辑的作用
		 return false ;
	 }
	 let puncs = ['~','`','!','@','#','$','%','^','&','*','(',')','-','_','+','=',',','.','<','>','?','/',' '] ;
     if ( (k >= 'a' && k <= 'z')|| (k >= 'A' && k <= 'Z')|| (k >= '0' && k <= '9'))  {
		 console.log("letters") ;
		 return true ;
     }
	 for (let p of puncs ){
	  if (p === k) {
		   console.log("puncs") ;
          return true ;
		 }
	 }
	 return false ;
      //提出更高阶的问题，如何处理连续空格和制表键tab？
	}	//function printLetter(k)
 });
 } //Code Block  End
function $(ele){
        if (typeof ele !== 'string'){
           throw("自定义的$函数参数的数据类型错误，实参必须是字符串！");
           return
        }
        let dom = document.getElementById(ele) ;
          if(dom){
            return dom ;
          }else{
            dom = document.querySelector(ele) ;
            if (dom) {
                return dom ;
            }else{
                throw("执行$函数未能在页面上获取任何元素，请自查问题！");
                return ;
            }
          }
       } //end of $
 // 更新显示的图片
 function updateImage() {
  document.getElementById('bookface').style.backgroundImage = `url('${images[currentIndex]}')`;
}

// 点击前进按钮
document.getElementById('forwardBtn').addEventListener('click', function() {
  currentIndex = (currentIndex + 1) % images.length;
  updateImage();
});
// 点击后退按钮
document.getElementById('backwardBtn').addEventListener('click', function() {
  currentIndex = (currentIndex - 1 + images.length) % images.length;
  updateImage();
});
// 下一张图片
function nextImage() {
  currentIndex = (currentIndex + 1) % images.length;
  updateImage();
}

// 初始化显示第一张图片
updateImage();

// 自动播放
intervalId = setInterval(nextImage, 3000);

// 停止自动播放
document.getElementById('pauseBtn').addEventListener('click', function() {
  clearInterval(intervalId);
});

// 切换自动播放状态
document.getElementById('pauseBtn').addEventListener('click', function() {
  const pauseBtn = document.getElementById('pauseBtn');
  if (isPlaying) {
    clearInterval(intervalId); // 停止自动播放
    pauseBtn.textContent = '开始播放'; // 更改按钮文本
  } else {
    intervalId = setInterval(nextImage, 3000); // 开始自动播放
    pauseBtn.textContent = '暂停播放'; // 更改按钮文本
  }
  isPlaying = !isPlaying; // 切换播放状态
});
 </script>
 </body>
</html>